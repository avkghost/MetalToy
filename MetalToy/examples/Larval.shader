{
  "fragment" : "typedef struct\n{\n   float2 resolution;\n   float time;\n} Uniforms;\n\nconstexpr sampler textureSampler (mag_filter::linear, min_filter::linear);\n\n#define kRaymarchIterations 24\n#define kIFSIterations 16\n\nconstant float3 vGlowColour = float3(1.0, 0.075, 0.01) * 5.0;\nconstant float3 vEnvColour = float3(0.1, 0.5, 1.0) * 2.0;\n\nconstant float kExposure = 0.1;\n\n\/\/ KIFS parameters\nconstant float fScale=1.25;\nconstant float3 vOffset = float3(-1.0,-2.0,-0.2);\n\nconstant float kFarClip = 30.0;\n\n\n\/\/ float3& vpos\nfloat2 GetSceneDistance(float3 vPos, const float3x3 m )\n{\n\tfloat fTrap = kFarClip;\n\t\n\tfloat fTotalScale = 1.0;\n\tfor(int i=0; i<kIFSIterations; i++)\n\t{\t\n\t\tvPos.xyz = abs(vPos.xyz);\n\t\tvPos *= fScale;\n\t\tfTotalScale *= fScale;\n\t\tvPos += vOffset;\n\t\tvPos.xyz = (vPos.xyz) * m;\n\t\t\n\t\tfloat fCurrDist = length(vPos.xyz) * fTotalScale;\n\t\t\/\/float fCurrDist = max(max(vPos.x, vPos.y), vPos.z) * fTotalScale;\n\t\t\/\/float fCurrDist = dot(vPos.xyz, vPos.xyz);\/\/ * fTotalScale;\t\t\n\t\tfTrap = min(fTrap, fCurrDist);\n\t}\n\n\tfloat l = length(vPos.xyz) \/ fTotalScale;\n\t\n\tfloat fDist = l - 0.1;\n\treturn float2(fDist, fTrap);\n}\n\nfloat4 Raycast( const float3 vOrigin, const float3 vDir, const float3x3 m )\n{\n\tfloat fClosest = kFarClip;\n\tfloat2 d = float2(0.0);\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n\t\td = GetSceneDistance(vOrigin + vDir * t, m);\n\t\tfClosest = min(fClosest, d.x \/ t);\n\t\tif(abs(d.x) < 0.0001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.x;\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn float4(t, d.x, d.y, fClosest);\n}\n\nfloat3 GetSceneNormal( const float3 vPos, const float3x3 m )\n{\n    const float fDelta = 0.000001;\n\n    float3 vOffset1 = float3( fDelta, -fDelta, -fDelta);\n    float3 vOffset2 = float3(-fDelta, -fDelta,  fDelta);\n    float3 vOffset3 = float3(-fDelta,  fDelta, -fDelta);\n    float3 vOffset4 = float3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetSceneDistance( vPos + vOffset1, m ).x;\n    float f2 = GetSceneDistance( vPos + vOffset2, m ).x;\n    float f3 = GetSceneDistance( vPos + vOffset3, m ).x;\n    float f4 = GetSceneDistance( vPos + vOffset4, m ).x;\n\n    float3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\nfloat3 TraceRay( const float3 vOrigin, const float3 vDir, const float3x3 m )\n{\t\n\tfloat4 vHit = Raycast(vOrigin, vDir, m);\n\t\n\tfloat3 vHitPos = vOrigin + vDir * vHit.x;\n\tfloat3 vHitNormal = GetSceneNormal(vHitPos, m);\n\t\n\tfloat fShade = 1.0;\n\tfloat fGlow = 0.0;\n\tfloat3 vEnvDir = vDir;\n\tif(vHit.x < kFarClip)\n\t{\n\t\tvEnvDir = reflect(vDir, vHitNormal);\n\t\tfGlow = clamp(vHit.z * 0.1, 0.0, 1.0);\n\t\tfGlow = pow(fGlow, 3.0);\n\t\tfShade = fGlow;\n\t}\n\t\n\t\/\/float3 vEnv = texture(iChannel0, vEnvDir).rgb;\n\t\/\/vEnv = vEnv * vEnv;\t\n\t\/\/vEnv = -log2(1.0 - min(vEnv, 0.99));\n\tfloat3 vEnv = float3(0.0);\n\n\tvEnv *= vEnvColour;\n\t\n\tfloat3 vColour = vEnv * (0.25 + fShade * 0.75);\n\t\n\t\/\/ inner glow\n\tif(vHit.x < kFarClip)\n\t{\t\n\t\tvColour += vGlowColour * 10.0 * fGlow;\n\t}\n\n\t\/\/ outer glow\n\t{\t\t\t\t\n\t\tfloat f = 1.0 - clamp(vHit.w * 0.5, 0.0, 1.0);\t\t\n\t\t\n\t\tfloat fGlowAmount = 0.0;\n\t\t\n\t\t\/\/ big glow\n\t\tfloat f1 = pow(f, 20.0);\n\t\tfGlowAmount += f1 * 2.0 * (0.5 + fShade * 0.5);\n\t\n\t\t\/\/ small glow\n\t\tfloat f2 = pow(f, 200.0);\n\t\tfGlowAmount += f2 * 5.0 * fShade;\n\t\t\n\t\tvColour += vGlowColour * fGlowAmount;\n\t}\n\t\n\treturn vColour;\n}\n\n\n\/\/ mat3 from quaternion\nfloat3x3 SetRot( const float4 q )\n{\n\tfloat4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn float3x3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\/\/ mat3 from axis \/ angle\nfloat3x3 SetRot( float3 vAxis, float fAngle )\n{\t\n\treturn SetRot( float4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\nfloat3 ApplyPostFx( const float3 vIn, const float2 fragCoord, const float2 resolution )\n{\n\tfloat2 vUV = fragCoord.xy \/ resolution.xy;\n\tfloat2 vCentreOffset = (vUV - 0.5) * 2.0;\n\t\n\tfloat3 vResult = vIn;\n\tvResult.xyz *= clamp(1.0 - dot(vCentreOffset, vCentreOffset) * 0.4, 0.0, 1.0);\n\n\tvResult.xyz = 1.0 - exp(vResult.xyz * -kExposure);\n\t\n\tvResult.xyz = pow(vResult.xyz, float3(1.0 \/ 2.2));\n\t\n\treturn vResult;\n}\n\nfragment float4 fragmentShader(FragmentData in [[stage_in]],\n                               texture2d<float> texture0 [[texture(0)]],\n                               texture2d<float> texture1 [[texture(1)]],\n                               texture2d<float> texture2 [[texture(2)]],\n                               texture2d<float> texture3 [[texture(3)]],\n                               constant Uniforms& uniforms [[buffer(1)]])\n{\n   float2 vUV = in.fragCoord.xy \/ uniforms.resolution;\n\n\tfloat2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= uniforms.resolution.x \/ uniforms.resolution.y;\n\t\n\tfloat fHeading = uniforms.time * 0.21;\n\tfloat fElevation = cos(uniforms.time * 0.1) * 0.5;\n\tfloat fCameraDistance = 15.0 + sin(uniforms.time * 0.05) * 5.0;\n\t\n\tfloat fSinElevation = sin(fElevation);\n\tfloat fCosElevation = cos(fElevation);\n\tfloat fSinHeading = sin(fHeading);\n\tfloat fCosHeading = cos(fHeading);\n\t\n\tfloat3 vCameraOffset;\n\tvCameraOffset.x = fSinHeading * fCosElevation;\n\tvCameraOffset.y = fSinElevation;\n\tvCameraOffset.z = fCosHeading * fCosElevation;\n\t\n\tfloat3 vCameraPos = vCameraOffset * fCameraDistance;\n\n\tfloat3 vCameraTarget = float3(0.0, 0.0, 0.0);\n\t\n\tfloat3 vForward = normalize(vCameraTarget - vCameraPos);\n\tfloat3 vRight = normalize(cross(float3(0.0, 1.0, 0.0), vForward));\n\tfloat3 vUp = normalize(cross(vForward, vRight));\n\t\n\tfloat fFov = 2.0;\n\t\n\tfloat3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFov);\n\t\n\tfloat3 vRotationAxis = float3(1.0, 4.0, 2.0);\n\n\t\/\/ Rotate the rotation axis\n\tfloat3x3 m2 = SetRot( float3(0.1, 1.0, 0.01), uniforms.time * 0.3 );\t\t\n\t\n\tvRotationAxis = vRotationAxis * m2;\n\t\n\tfloat fRotationAngle = sin(uniforms.time * 0.5);\n\t\n\tfloat3x3 m = SetRot(vRotationAxis, fRotationAngle);\n\t\n\tfloat3 vResult = TraceRay(vCameraPos, vDir, m);\n\t\n\tvResult = ApplyPostFx(vResult, in.fragCoord.xy, uniforms.resolution);\n\t\n\treturn float4(vResult,1.0);\n}",
  "textures" : [
    "NULL",
    "NULL",
    "NULL",
    "NULL"
  ]
}