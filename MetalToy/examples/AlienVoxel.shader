{
  "fragment" : "\/\/------------------------------------------------------------------------\n\/\/ Alien Voxel Landscape\n\/\/ by @BradyInstead\n\/\/------------------------------------------------------------------------\n\ntypedef struct\n{\n   float2 resolution;\n   float time;\n} Uniforms;\n\nconstexpr sampler textureSampler (mag_filter::linear, min_filter::linear);\n\n\nvoid doCamera(thread float3& camPos, thread float3& camTar, float time)\n{\n    float zoom = 50.;\n    float3 initPos = float3(zoom);\n\n\t camPos = initPos;\n    camPos.z += time * 16.0; \/\/ movement\n    camTar = camPos - initPos;\n}\n\nfloat3 doBackground()\n{\n    return float3( 0.);\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Shaping \n\/\/------------------------------------------------------------------------\n\n\/\/ p = positions\n\/\/ h = dimensions of elongation\nfloat4 opElongate(float3 p, float3 h )\n{\n    float3 q = abs(p) - h;\n    return float4( max(q, 0.0), min(max(q.x, max(q.y, q.z)), 0.0));\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5 * (d2 - d1) \/ k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k * h * (1.0 - h);\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Modelling \n\/\/------------------------------------------------------------------------\n\nfloat noise(float3 P)\n{\n    \/\/  https:\/\/github.com\/BrianSharpe\/Wombat\/blob\/master\/Value3D.glsl\n\n    \/\/ establish our grid cell and unit position\n    float3 Pi = floor(P);\n    float3 Pf = P - Pi;\n    \/\/float3 Pf_min1 = Pf - 1.0;\n\n    \/\/ clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 \/ 69.0 )) * 69.0;\n    float3 Pi_inc1 = step( Pi, float3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    \/\/ calculate the hash\n    float4 Pt = float4( Pi.xy, Pi_inc1.xy ) + float2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    float2 hash_mod = float2( 1.0 \/ ( 635.298681 + float2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    float4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    float4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    \/\/\tblend the results and return\n    float3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    float4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    float4 blend2 = float4( blend.xy, float2( 1.0 - blend.xy ) );\n\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nfloat mapTerrain(float3 p )\n{\n    p *= .35;\n    p.y \/= 2.;\n\n\treturn noise(p);\n}\n\nfloat map(float3 p)\n{\n\tfloat terrain = mapTerrain( p ) + 0.12*p.y;\n\n\treturn step( terrain, 0.95 );\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Material\n\/\/------------------------------------------------------------------------\n\nfloat3 doMaterial(float3 pos, float3 vos )\n{\n    float h = vos.y\/8.;\n    \n    float3 primary = float3(.9, .1, .2) ;\n    float3 secondary = float3(.1, .5, 1.);\n    \n    return mix(primary, secondary, h)*h;\n}\n\nfloat3 saturation(float3 rgb, float adjustment)\n{\n    \/\/ Algorithm from Chapter 16 of OpenGL Shading Language\n    const float3 W = float3(0.2125, 0.7154, 0.0721);\n    float3 intensity = float3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nfloat maxcomp(float4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge(float2 uv, float4 va, float4 vb, float4 vc, float4 vd )\n{\n    float2 st = 1.0 - uv;\n\n    \/\/ edges\n    float4 wb = smoothstep( 0.7, 0.99, float4(uv.x,\n                                              st.x,\n                                              uv.y,\n                                              st.y) ) * ( 1.0 - va + va*vc );\n    \/\/ corners\n    float4 wc = smoothstep( 0.7, 0.99, float4(uv.x*uv.y,\n                                              st.x*uv.y,\n                                              st.x*st.y,\n                                              uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return 1.0 - maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc(float2 uv, float4 va, float4 vb, float4 vc, float4 vd )\n{\n    float2 st = 1.0 - uv;\n\n    \/\/ edges\n    float4 wa = float4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    \/\/ corners\n    float4 wb = float4(uv.x*uv.y,\n                       st.x*uv.y,\n                       st.x*st.y,\n                       uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nfloat3 doLighting(float3 pos, float3 nor, float3 rd, float dis, float3 mal , float3 vos, float3 dir)\n{\n    float3 uvw = pos - vos;\n    \n   float3 v1  = vos + nor + dir.yzx;\n   float3 v2  = vos + nor - dir.yzx;\n\tfloat3 v3  = vos + nor + dir.zxy;\n\tfloat3 v4  = vos + nor - dir.zxy;\n\tfloat3 v5  = vos + nor + dir.yzx + dir.zxy;\n   float3 v6  = vos + nor - dir.yzx + dir.zxy;\n\tfloat3 v7  = vos + nor - dir.yzx - dir.zxy;\n\tfloat3 v8  = vos + nor + dir.yzx - dir.zxy;\n\tfloat3 v9  = vos + dir.yzx;\n\tfloat3 v10 = vos - dir.yzx;\n\tfloat3 v11 = vos + dir.zxy;\n\tfloat3 v12 = vos - dir.zxy;\n \tfloat3 v13 = vos + dir.yzx + dir.zxy; \n\tfloat3 v14 = vos - dir.yzx + dir.zxy;\n\tfloat3 v15 = vos - dir.yzx - dir.zxy;\n\tfloat3 v16 = vos + dir.yzx - dir.zxy;\n\n\tfloat4 vc = float4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\tfloat4 vd = float4( map(v5),  map(v6),  map(v7),  map(v8)  );\n   float4 va = float4( map(v9),  map(v10), map(v11), map(v12) );\n\tfloat4 vb = float4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\tfloat2 uv = float2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n    \n    \/\/ ambient occlusion\n    float occ = 1.0;\n    occ = calcOcc( uv, va, vb, vc, vd );\n    float ocAm = 3.0;\n    occ = 1.0 - occ\/ocAm;\n    occ = pow(occ, 5.);\n    \n    \/\/ fake lighting\n    float3 norC = abs(nor);\n    float sum = min(1.0, norC.g + norC.r*.35 + norC.b*.2 + .05);\n    float3 col = mal*sum*isEdge(uv, va, vb, vc, vd);\n    \n    col = mix(col.rgb*occ, float3(col.rg*occ, col.b), .2);\n    \n    return col;\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Raymarching\n\/\/------------------------------------------------------------------------\n\nfloat calcIntersection(float3 ro, float3 rd, thread float3& oVos, thread float3& oDir, thread int& mat )\n{\n\tfloat3 pos = floor(ro);\n\tfloat3 ri = 1.0\/rd;\n\tfloat3 rs = sign(rd);\n\tfloat3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tfloat3 mm = float3(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\t\/\/float3 nor = -mm*rs;\n\tfloat3 vos = pos;\n\t\n    \/\/ intersect the cube\t\n\tfloat3 mini = (pos-ro + 0.5 - 0.5*float3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nfloat3x3 calcLookAtMatrix(float3 ro, float3 ta, float roll )\n{\n    float3 ww = normalize( ta - ro );\n    float3 uu = normalize( cross(ww,float3(sin(roll),cos(roll),0.0) ) );\n    float3 vv = normalize( cross(uu,ww));\n    return float3x3( uu, vv, ww );\n}\n\n\nfragment float4 fragmentShader(FragmentData in [[stage_in]],\n                               texture2d<float> texture0 [[texture(0)]],\n                               texture2d<float> texture1 [[texture(1)]],\n                               texture2d<float> texture2 [[texture(2)]],\n                               texture2d<float> texture3 [[texture(3)]],\n                               constant Uniforms& uniforms [[buffer(1)]])\n{\n    \/\/float2 uv = in.fragCoord.xy \/ uniforms.resolution;\n    \/\/return float4(uv, 0.5 + 0.5 * sin(uniforms.time), 1.0);\n\n\tfloat2 p = (-in.fragCoord.xy + 2.0 * in.fragCoord.xy) \/ uniforms.resolution.y;\n    p.x \/= 1.25;\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n    \n    \/\/ camera movement\n    float3 ro, ta;\n    doCamera( ro, ta, uniforms.time);\n\n    \/\/ camera matrix\n    float3x3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tfloat3 rd = normalize( float3(p.xy,1.0) ); \/\/ lens length\n    rd.y -= 1.0;\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tfloat3 col = doBackground();\n\n\t\/\/ raymarch\n    float3 vos, dir;\n    int mat;\n    float t = calcIntersection( ro, rd, vos, dir, mat );\n    if( t>0.0 )\n    {\n        \/\/ geometry\n        float3 pos = ro + t*rd;\n        float3 nor = -dir*sign(rd);\n\n        \/\/ materials\n        float3 mal = doMaterial( pos, vos );\n\n        col = doLighting( pos, nor, rd, t, mal, vos, dir);\n\t}\n\n    \n    col *= 1.5;\n    col -= .03;\n    \n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), float3(0.5) );\n    \n    \/\/ saturation\n\tcol = saturation(col, 2.0);   \n    \n    return float4( col, 1.0 );\n}",
  "textures" : [
    "NULL",
    "NULL",
    "NULL",
    "NULL"
  ]
}